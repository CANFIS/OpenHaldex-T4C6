#ifndef WIFI_H
#define WIFI_H

// Details of the Wi-Fi AP that is generated by the ESP32 for serving the "Update" webpage
const char wifi_ap_ssid[] = "OpenHaldex";
char wifi_ap_pass[] = "OpenHaldexT4C6";

// Libraries for everything related to Wi-Fi
#include <nvs_flash.h>
#include <esp_netif.h>
#include <esp_wifi.h>
#include <mdns.h>
#include <esp_ota_ops.h>
#include <esp_http_server.h>
#include "http_server_handler.h"

// ESP32 core compilation error fix
#include "lwip/netif.h"
extern "C" int lwip_hook_ip6_input(struct pbuf *p, struct netif *inp) __attribute__((weak));
extern "C" int lwip_hook_ip6_input(struct pbuf *p, struct netif *inp) {
  if (ip6_addr_isany_val(inp->ip6_addr[0].u_addr.ip6)) {
    pbuf_free(p);
    return 1;
  }
  return 0;
}

// Initialize NVS
void init_nvs()
{
  esp_err_t ret = nvs_flash_init();
  if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)
  {
    ESP_ERROR_CHECK(nvs_flash_erase());
    ESP_ERROR_CHECK(nvs_flash_init());
  }
  else if (ret != ESP_OK)
  {
    ESP_ERROR_CHECK(ret);
  }
}

// EventGroup for Wi-Fi events
EventGroupHandle_t s_wifi_event_group;
#define WIFI_CONNECTED_BIT (1ULL << 0)
#define WIFI_FAIL_BIT (1ULL << 1)
#define WIFI_DISCONNECTED_BIT (1ULL << 2)

// Maximum amount of retries for connecting to the hotspot
#define WIFI_STA_CONNECT_MAXIMUM_RETRY 5
uint8_t wifi_sta_connect_attempts = 0;

// Callback triggered when receiving a Wi-Fi event
void wifi_sta_event_handler(void *arg, esp_event_base_t event_base, int32_t event_id, void *event_data)
{
  if (event_base == WIFI_EVENT)
  {
    switch (event_id)
    {
      // Connecting to the hotspot failed, or was disconnected after connecting
      case WIFI_EVENT_STA_DISCONNECTED:
        {
          DEBUG("Event: Wi-Fi disconnected");
          xEventGroupSetBits(s_wifi_event_group, WIFI_DISCONNECTED_BIT);
          mySocketFD = 0;

          // Don't try to reconnect if the attempts counter is set to 0.
          if (wifi_sta_connect_attempts)
          {
            DEBUG("Connecting to the Wi-Fi Station failed");

            // Try to reconnect, without exceeding the maximum amount of retries.
            if (wifi_sta_connect_attempts < WIFI_STA_CONNECT_MAXIMUM_RETRY)
            {
              DEBUG("Retry %d", wifi_sta_connect_attempts);
              esp_wifi_connect();
              wifi_sta_connect_attempts++;
            }
            else
            {
              xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);
            }
          }
        }
        break;
      case WIFI_EVENT_HOME_CHANNEL_CHANGE:
        {
          /*
            uint8_t new_channel = 0;
            wifi_second_chan_t dummy;
            esp_wifi_get_channel(&new_channel, &dummy);
            DEBUG("Event: Wi-Fi channel changed to %d", new_channel);
          */
        }
        break;
      default:
        {
          DEBUG("WIFI_EVENT: Unknown event_id: %ld", event_id);
        }
        break;
    }
  }
  else if (event_base == IP_EVENT)
  {
    switch (event_id)
    {
      // Connecting to the hotspot succeeded
      case IP_EVENT_STA_GOT_IP:
        {
          // Store the IP address, which will be displayed on the "Dashboard" webpage.
          sta_ip = ((ip_event_got_ip_t*)event_data)->ip_info.ip.addr;
          DEBUG("Got IP: " IPSTR, IP2STR((esp_ip4_addr_t*)&sta_ip));
          wifi_sta_connect_attempts = 0;
          xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);
        }
        break;
      default:
        {
          DEBUG("IP_EVENT: Unknown event_id");
        }
        break;
    }
  }
  else
  {
    DEBUG("Unknown event_base");
  }
}

// Initialize the Wi-Fi layer
void init_wifi()
{
  // NETIF
  ESP_ERROR_CHECK(esp_netif_init());
  ESP_ERROR_CHECK(esp_event_loop_create_default());

  // AP
  esp_netif_t *wifiAP = esp_netif_create_default_wifi_ap();
  esp_netif_ip_info_t ipInfo;
  IP4_ADDR(&ipInfo.ip, 192, 168, 1, 2);
  IP4_ADDR(&ipInfo.gw, 192, 168, 1, 2);
  IP4_ADDR(&ipInfo.netmask, 255, 255, 255, 0);
  esp_netif_dhcps_stop(wifiAP);
  esp_netif_set_ip_info(wifiAP, &ipInfo);
  esp_netif_dhcps_start(wifiAP);

  // STA
  esp_netif_t *sta_netif = esp_netif_create_default_wifi_sta();
  esp_netif_set_hostname(sta_netif, "OpenHaldex");
  s_wifi_event_group = xEventGroupCreate();
  esp_event_handler_instance_t instance_any_id, instance_got_ip;
  esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_sta_event_handler, NULL, &instance_any_id);
  esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &wifi_sta_event_handler, NULL, &instance_got_ip);

  // Wi-Fi
  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  ESP_ERROR_CHECK(esp_wifi_init(&cfg));
}

// Initialize MDNS, for the ability to access "openhaldex.local" (instead of using the IP address) on supported platforms (IOS, Windows)
void init_mdns()
{
  ESP_ERROR_CHECK(mdns_init());
  ESP_ERROR_CHECK(mdns_hostname_set("openhaldex"));
}

// Initialize everything necessary for Wi-Fi
void configure_wifi()
{
  init_nvs();
  init_wifi();
  init_mdns();
}

// HTTP server handle
httpd_handle_t server = NULL;

// Stop the HTTP server, if it's running
void stop_http_server()
{
  if (server)
  {
    httpd_stop(server);
    server = NULL;
  }
}

// Types of webpage to be sent by the HTTP server
enum wifi_page_t
{
  UPDATE_PAGE,
  DASHBOARD_PAGE
};

// Start the HTTP server, if it's not running
void start_http_server(wifi_page_t which_page)
{
  if (!server)
  {
    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    config.uri_match_fn = httpd_uri_match_wildcard;
    config.max_uri_handlers = 10;
    httpd_start(&server, &config);

    // URI handler for getting favicon.ico
    httpd_uri_t favicon_handler = {};
    favicon_handler.uri = "/favicon.ico";
    favicon_handler.method = HTTP_GET;
    favicon_handler.handler = send_favicon;
    favicon_handler.user_ctx = NULL;
    httpd_register_uri_handler(server, &favicon_handler);

    // URI handler for getting jquery.min.js
    httpd_uri_t jquery_min_js_handler = {};
    jquery_min_js_handler.uri = "/jquery.min.js";
    jquery_min_js_handler.method = HTTP_GET;
    jquery_min_js_handler.handler = send_jquery_min_js;
    jquery_min_js_handler.user_ctx = NULL;
    httpd_register_uri_handler(server, &jquery_min_js_handler);

    // URI handler for getting the background image
    httpd_uri_t background_image_handler = {};
    background_image_handler.uri = "/media/background.jpeg";
    background_image_handler.method = HTTP_GET;
    background_image_handler.handler = send_background_image;
    background_image_handler.user_ctx = NULL;
    httpd_register_uri_handler(server, &background_image_handler);

    // URI handler for getting the logo image
    httpd_uri_t logo_image_handler = {};
    logo_image_handler.uri = "/media/logo.png";
    logo_image_handler.method = HTTP_GET;
    logo_image_handler.handler = send_logo_image;
    logo_image_handler.user_ctx = NULL;
    httpd_register_uri_handler(server, &logo_image_handler);

    // URI handler for getting index.html
    httpd_uri_t index_html_handler = {};
    index_html_handler.uri = "/";
    index_html_handler.method = HTTP_GET;
    index_html_handler.user_ctx = NULL;
    switch (which_page)
    {
      case UPDATE_PAGE:
        {
          index_html_handler.handler = send_update_index_html;
        }
        break;
      case DASHBOARD_PAGE:
        {
          index_html_handler.handler = send_dashboard_index_html;
        }
        break;
    }
    httpd_register_uri_handler(server, &index_html_handler);

    switch (which_page)
    {
      case UPDATE_PAGE:
        {
          // URI handler for configuring Wi-Fi for automatic updates
          httpd_uri_t wifi_settings_handler = {};
          wifi_settings_handler.uri = "/set_wifi";
          wifi_settings_handler.method = HTTP_POST;
          wifi_settings_handler.handler = set_wifi_settings;
          wifi_settings_handler.user_ctx = NULL;
          httpd_register_uri_handler(server, &wifi_settings_handler);

          // URI handler for uploading firmware
          httpd_uri_t firmware_handler = {};
          firmware_handler.uri = "/update";
          firmware_handler.method = HTTP_POST;
          firmware_handler.handler = upload_firmware;
          firmware_handler.user_ctx = NULL;
          httpd_register_uri_handler(server, &firmware_handler);

          // URI handler for restarting after uploading firmware
          httpd_uri_t end_update_handler = {};
          end_update_handler.uri = "/end_update";
          end_update_handler.method = HTTP_GET;
          end_update_handler.handler = handle_end_update;
          end_update_handler.user_ctx = NULL;
          httpd_register_uri_handler(server, &end_update_handler);

          // URI handler for resetting the settings
          httpd_uri_t factory_reset_handler = {};
          factory_reset_handler.uri = "/format";
          factory_reset_handler.method = HTTP_GET;
          factory_reset_handler.handler = handle_factory_reset;
          factory_reset_handler.user_ctx = NULL;
          httpd_register_uri_handler(server, &factory_reset_handler);
        }
        break;
      case DASHBOARD_PAGE:
        {
          // URI handler for getting the current IP address
          httpd_uri_t ip_request_handler = {};
          ip_request_handler.uri = "/ip";
          ip_request_handler.method = HTTP_POST;
          ip_request_handler.handler = provide_ip;
          ip_request_handler.user_ctx = NULL;
          httpd_register_uri_handler(server, &ip_request_handler);

          // URI handler for configuring SSEs
          httpd_uri_t SSE_handler = {};
          SSE_handler.uri = "/sse";
          SSE_handler.method = HTTP_GET;
          SSE_handler.handler = handle_sse;
          SSE_handler.user_ctx = NULL;
          httpd_register_uri_handler(server, &SSE_handler);

          // URI handler for setting OpenHaldex mode
          httpd_uri_t set_mode_handler = {};
          set_mode_handler.uri = "/set_mode";
          set_mode_handler.method = HTTP_POST;
          set_mode_handler.handler = handle_set_mode;
          set_mode_handler.user_ctx = NULL;
          httpd_register_uri_handler(server, &set_mode_handler);
        }
        break;
    }
  }
}

// Function used for sending an SSE
void send_sse(char *data_buf, char *event_name)
{
  // Format of an SSE:
  static const char *sse_format = "event: %s" "\r\n"
                                  "data: %s" "\r\n"
                                  "\r\n";
  static const size_t sse_format_length_without_specifiers = sizeof(sse_format) - 5;

  // The SSE can only be sent if the websocket file descriptor is valid.
  if (mySocketFD <= 0)
  {
    return;
  }

  // Buffer to hold the SSE string:
  static char sse_buf[256];

  // Abort if the string can't fit in the buffer.
  size_t total_sse_length = sse_format_length_without_specifiers + strlen(event_name) + strlen(data_buf);
  if (total_sse_length >= sizeof(sse_buf))
  {
    return;
  }

  // Store the SSE in the buffer and send it.
  snprintf(sse_buf, sizeof(sse_buf), sse_format, event_name, data_buf);
  httpd_socket_send(mySocketHD, mySocketFD, sse_buf, strlen(sse_buf), 0);
}

#endif
